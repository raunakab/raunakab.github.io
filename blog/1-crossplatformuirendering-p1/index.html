<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>@rabh | Cross-Platform UI Rendering - (Part 1)</title>
    
    <link rel="stylesheet" href="https://raunakab.github.io/style.css?h=a029ba9105b164952234">
    
    
    
    
</head>
<body>
    
<header class="space">
    <a href="https:&#x2F;&#x2F;raunakab.github.io">&LeftArrow; Home</a>
</header>

    
<main>
    <h1>Cross-Platform UI Rendering - (Part 1)</h1>
    
    <p class="secondary">10 June, 2024</p>
    
    <div class="space"></div>
    <h1 id="prelude">Prelude</h1>
<p>The <em>UI rendering stack</em> consists of a set of various pieces of software all working together to turn high-level declarative descriptions of a UI into low-level CPU/GPU draw-calls which actually perform the data-writes to whatever screen-buffer(s) is(are) provided.</p>
<p>The canonical stack usually comprises of the following pieces of software (which may themselves be broken down into further libraries):</p>
<ol>
<li>A high level framework providing concise APIs to draw UI elements (such as Views, ScrollViews, Tabs, Buttons, etc.).</li>
<li>A rendering engine, capable of drawing primitive shapes (such as triangles and lines) using various color-brushes (solid, linear gradients, radial gradients, etc.).</li>
<li>An IO engine that registers user events, device events, window events, etc., and notifies the appropriate subscribers that said event has occurred.</li>
</ol>
<p>For example, consider this excerpt of Swift code using <a href="https://developer.apple.com/xcode/swiftui"><code>SwiftUI</code></a>:</p>
<pre data-linenos data-lang="swift" style="background-color:#0f1419;color:#bfbab0;" class="language-swift "><code class="language-swift" data-lang="swift"><table><tbody><tr><td>1</td><td><span style="color:#ff7733;">import </span><span style="font-style:italic;color:#39bae6;">SwiftUI
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span style="color:#ff7733;">struct</span><span> ContentView: View {
</span></td></tr><tr><td>4</td><td><span>  </span><span style="color:#ff7733;">var</span><span> body: some View {
</span></td></tr><tr><td>5</td><td><span>    Text(</span><span style="color:#c2d94c;">&quot;Hello, world!&quot;</span><span>)
</span></td></tr><tr><td>6</td><td><span>    Button(</span><span style="color:#c2d94c;">&quot;Click me!&quot;</span><span>) {
</span></td></tr><tr><td>7</td><td><span>      </span><span style="font-style:italic;color:#5c6773;">// Code inside of this block is run whenever the button is pressed
</span></td></tr><tr><td>8</td><td><span>    }
</span></td></tr><tr><td>9</td><td><span>  }
</span></td></tr><tr><td>10</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>In this (purposefully limited) example, we can see a high-level description of what the UI should look like:
a simple <code>View</code> structure that contains two sub structures; one being a <code>Text</code> structure that contains the string <code>&quot;Hello, world!&quot;</code>, and the other a <code>Button</code> structure which contains the string <code>&quot;Click me!&quot;</code> and is pressable.
The <code>Button</code> structure also has the added feature of being able to run some logic only when it is pressed.</p>
<p>This high-level description of a UI is the &quot;high-level framework&quot;, <code>SwiftUI</code>, at play.
Once it is being run, it will need to do a couple of things.
Firstly, it will need to layout those structures somewhere within the canvas (i.e., find each of their positionings, heights, and widths).
Secondly, it will then need to call into the rendering engine to perform those low-level CPU/GPU draw calls that will eventually paint the appropriate pixels with the correct colors.
And finally, in the case that any form of user/device/window event is registered, the IO engine will need to send a signal to the high-level framework notifying it of what has happened.
The high-level framework can then <em>redraw/update</em> those <code>View</code>, <code>Text</code>, and <code>Button</code> structures accordingly.</p>
<p>This is how those above 3 components of the UI stack all intermingle with one another.
You describe some structures in a high-level fashion, the high-level framework lays out those structure and transforms that layout into low-level draw calls, and then an IO-engine signals to the high-level framework when those structures need to be redrawn.</p>
<p>This stack exists in many forms for many different platforms.
The only problem is that these stacks are <strong>platform-dependent</strong>.
You can't run applications developed using the <code>SwiftUI</code> stack on an Android phone.</p>
<p>For that, you'll need a <em>cross-platform UI stack</em>.</p>
<br>
<h1 id="intro">Intro</h1>
<p>Cross-platform UI rendering technically isn't novel.
Interestingly enough, one of the most widely distributed standards in the world (if not <em>the</em> most), pertains to cross-platform UI rendering in and of itself.
In fact, you're probably using that global standard right now to view this article: the W3C specification.</p>
<p>Without getting too bogged down in the details, the W3C specification is a worldwide standard that provides a detailed description on how HTML+CSS <em>should</em> be rendered.
It contains other topics as well, such as the ECMAScript language standard, but the primary goal of that standard is to unify the rendering of HTML+CSS.</p>
<p><em>That</em> is how you're viewing this article:</p>
<ul>
<li>Some developer writes some HTML source code</li>
<li>Your browser, upon navigating to that developer's website, requests that HTML source code and downloads it</li>
<li>Your browser then takes that downloaded HTML and (using the guidelines provided by the W3C standard) turns it into a <em>rendered output on your screen</em></li>
</ul>
<p>Now here's the beauty in all of that:
The W3C standard is <em>platform agnostic!</em>
That means that it wasn't designed to only run on iPhones or Androids.
Nor was it designed to only run on MacBooks or Linux PCs.
It was designed to be flexible enough that any platform could implement an HTML+CSS rendering engine and render any HTML source code.
The end result is that you can write some generic HTML code, give it to a random group of people, and (without knowing what devices they're all using) have that HTML source code be rendered very similarly across all of their various devices.</p>
<p>That is as close to true cross-platform UI rendering as one can be.
Yes, sometimes there can be discrepancies, but for mainly all intents and purposes, those discrepancies are somewhat uncommon to run into.</p>
<p>So for our purposes, we will consider it to be a truly cross-platform UI rendering solution.</p>
<p>But here are where the problems start.</p>
<br>
<h1 id="old-technologies-in-a-new-era">Old technologies in a new era</h1>
<p>The W3C standard is old.
It was originally concepted in 1994.
Even though it has gone through <em>numerous</em> iterations and has been steadily modernizing to keep up with the high-quality UI/UX features that consumers expect nowadays, the original &quot;stink&quot; still remains.</p>
<p>The W3C standard defines HTML specification.
The HTML specification was created to define web <em>pages</em> - not web <em>apps</em>.
Those two things are <strong>PHENOMENALLY</strong> different from one another.
Here's an example of a web page and a web app.
Try to see if you can intuitively feel the differences.</p>
<ol>
<li><a href="https://scons.org/doc/production/HTML/scons-man.html">SCons doc site</a> (web page)</li>
<li><a href="https://youtube.com/">YouTube</a> (web app)</li>
</ol>
<p>The first one is a static site.
It doesn't have animations popping up or any dynamic motions in it.
What you see is what you get.
It's almost as if a real piece of paper became digitalized and found its way onto your screen.
That is a web <em>page</em>.</p>
<p>The other is a complex, dynamic experience that changes its content everytime you refresh the page.
When you hover on one of the thumbnails, it smoothly enlarges and starts autoplaying its contents.
The left side also contains a tab-bar with notifications and alerts that constantly update as new content is pumped out.
That is a web <em>app</em>.</p>
<p>The original W3C standard (designed in 1994, mind you) was designed to support the former: a simple web page.
There's nothing complex about it, because complex web apps were <em>not a thing back in the 1990s.</em>
The purpose of the HTML specification was for developers to send &quot;static, digital pieces of paper&quot; around to one another.</p>
<p>However, as time progressed and more complex UI/UX features were desired (i.e., animations), the W3C standard was updated.
One of those updates was the inclusion of ECMAScript: a scripting language that could run client-side to dynamically update the contents of the page, thereby making the page feel more ... <em>&quot;app-like&quot;</em>.</p>
<p>But even considering those updates, web apps still fail to be truly immersive applications.
There are still remnant artifacts of them being <em>web-rendered</em> applications that make them feel unnatural.
For example, navigate to the <a href="https://youtube.com">YouTube</a> site, click on the top-left of your screen, and drag down to the bottom-left.
You'll notice that this highlights all of the text <strong>and</strong> the thumbnails!
This is a feature that <em>must</em> be included according to the W3C standard, but it doesn't make any sense for thumbnails to be highlight-able.</p>
<br>
<p>So what's my point here?
Well:</p>
<ol>
<li>Most pieces of software nowadays require an application.</li>
<li>The most convenient way to make an application that <em>everyone</em> (not just iPhone users or Android users) can use is to make a web app.</li>
<li>But web apps suck. Most consumers largely prefer to use native applications instead.</li>
<li>Native applications are <em>not</em> cross platform! If you want to build a native iOS application, it will <em>not</em> run on Android phones! That means you need to develop a whole other native application for Androids! Which then means two separate development teams creating two separate applications that do essentially the same thing<sup class="footnote-reference"><a href="#1">1</a></sup>. And that's also forgetting macOS, Windows, and Linux apps...</li>
</ol>
<br>
<h1 id="solution">Solution</h1>
<p>There do exist <em>some</em> tools out there which provide a &quot;pseudo&quot; cross-platform rendering experience.
The most notable here would be <a href="https://reactnative.dev"><code>React Native</code></a><sup class="footnote-reference"><a href="#2">2</a></sup>.
However, there are some limitations with React Native.
Namely, it cannot compile applications to WASM and distribute them across the web in a platform agnostic manner (since the core of React Native must link to a specific platform's native component library first, which cannot be included in a WASM executable).</p>
<p>So what do we do?</p>
<p>Well... I think we'll need to reinvent (or better yet, <em>redesign</em>) the wheel here.
I think a potential solution exists in understanding how UI stacks are <em>distributed</em> to end-clients in the first place.
And for that, our very next step will be to explore the offerings of <a href="https://webassembly.org"><code>WASM</code></a> and <a href="https://www.w3.org/TR/webgpu"><code>WebGPU</code></a>.</p>
<br>
<p><em>This is the first post in a series.
Future posts will soon come.</em></p>
<br>
<br>
<br>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>There are ways of reducing the duplication of logic.
It is possible to write the core business logic in a library which can then be integrated into the platform-dependent native applications individually (for example, by compiling the library down to a shared-object and dynamically linking to its symbols during runtime).
However, the <em>rendering logic</em> will still need to be duplicated.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The reason why I say React Native provides a &quot;somewhat&quot; cross-platform experience is because it technically just links to the native components provided by that platform's native component library which are rendered by that platform's native rendering engine.
I.e., it doesn't define a new component library rendered via <em>truly</em> cross-platform rendering engine.
This technically means that you can observe divergent behaviours across various platforms.
However, to the end-developer, those differences are rarely encountered, so React Native can be considered cross-platform enough for us.</p>
</div>

</main>

    <div class="dark-mode-buttons">
        <button class="dark-mode-button" id="dark-mode-on"><img src="https://raunakab.github.io/dark_mode.svg" width="24" height="24" alt="Dark mode" aria-label="dark mode toggle" title="Dark mode"></button>
        <button class="dark-mode-button" id="dark-mode-off"><img src="https://raunakab.github.io/light_mode.svg" width="24" height="24" alt="Light mode" aria-label="light mode toggle" title="Light mode"></button>
    </div>
    <script>
        const cls = document.body.classList;
        const getSessionTheme = sessionStorage.getItem("theme");
        if (getSessionTheme === "dark") {
            cls.toggle("dark-mode", true);
        } else if (getSessionTheme === "light") {
            cls.toggle("dark-mode", false);
        } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
            cls.toggle("dark-mode", true);
        }

        document.getElementById("dark-mode-on").addEventListener("click", function(e) {
            cls.toggle("dark-mode", true);
            sessionStorage.setItem("theme", "dark");
        });
        document.getElementById("dark-mode-off").addEventListener("click", function(e) {
            cls.toggle("dark-mode", false);
            sessionStorage.setItem("theme", "light");
        });
    </script>
    <noscript>
        <style>
            .dark-mode-buttons {
                display: none;
            }
        </style>
    </noscript>
</body>
</html>
