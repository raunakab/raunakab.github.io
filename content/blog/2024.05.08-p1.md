+++
title = "Frontend Rendering - (Part 2)"
date = 2024-05-08
+++

<br>

# Table of Contents
This is one post in a series of posts.
- Click [here](../2024-05-04-p1) to go to Part 1.

<br>

# Getting Started
In the previous article, I mentioned that [WebGPU](https://www.w3.org/TR/webgpu) has the capability of opening up mutliple doors in terms of cross-platform rendering.
Although I want to dive deeper into what it can provide for us, I first need to "ease" myself into working with it.
Although it's a capable API, WebGPU is also a very *complex* API.
It's known for having a large surface area and it'll be easy for me to get caught in the nuances of it if I try to master it in a single sitdown.
To give you an idea of its scale, rendering even a single simple shape (such as a square) will take about 200-300 significant lines of code.
(This level of verbosity makes sense, however; they want to give you as much description power as possible).

I am sure that I will need to learn and master WebGPU at some point in the coming future, but I want to tackle slightly higher-level problems first before diving that deep.
The best way for me to "ease" into it would be for me to *understand how already existing consumers work with it*.
The best way of learning in this case is by reverse-engineering.

I've found a nice 2D rendering library called [`vello`](https://github.com/linebender/vello).
`vello` provides a set of *simpler* APIs on top of WebGPU.
For example, instead of drawing a simple triangle by meticulously instantiating render-pipeline, its layouts, writing the WGSL code, etc., you can simple just make a function call to `vello` and it'll take care of the rest of the setup.

To be fair, with all things considered, `vello` is still a much lower-level library compared to what we actually want out of a UI framework.
We would still want an *additional* layer of abstraction *on top* of `vello`.

# Noxi
This is where `noxi` comes into play.
`noxi` is a utility library that I'm writing on top of `vello` to help further abstract away the gritty details.
The idea for it will be for it to provide APIs to simply render even more complex objects such as text-runs, buttons, views, shadows, etc.
